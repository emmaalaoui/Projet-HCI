Index: studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from PyQt6.QtWidgets import QProgressBar, QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget\r\nfrom PyQt6.QtCore import Qt, QBasicTimer, pyqtSignal, QPointF, QPoint, QRect\r\nfrom PyQt6.QtGui import QPainter, QPixmap, QPen, QBrush, QCursor, QColor\r\nfrom PyQt6.QtTest import QTest\r\nimport time\r\nfrom piece import Piece\r\n\r\n\r\nclass Board(QWidget):  # base the board on a QFrame widget\r\n    updateTimerSignal = pyqtSignal(int)  # signal sent when timer is updated\r\n    clickLocationSignal = pyqtSignal(str)  # signal sent when there is a new click location\r\n\r\n    # TODO set the board width and height to be square\r\n    boardWidth = 6  # board is 0 squares wide # TODO this needs updating\r\n    boardHeight = 6  #\r\n    timerSpeed = 1000  # the timer updates every 1 millisecond\r\n    counter = 120  # the number the counter will count down from\r\n\r\n    def __init__(self, parent):\r\n        super().__init__(parent)\r\n        self.go = parent\r\n        self.initBoard()\r\n        self.image = QPixmap(\"./icons/Board.png\")\r\n        self.imageOrigin = QPixmap(\"./icons/Board.png\")\r\n        self.mainLabel = QLabel()\r\n        self.mainLabel.setPixmap(self.image)\r\n        self.mainLayout = QVBoxLayout()\r\n        self.setLayout(self.mainLayout)\r\n        self.resize(800, 1000)\r\n        self.draw = True\r\n        '''self.cursor = QCursor()\r\n        # self.image.setCursor(self.cursor)\r\n        #self.cursor.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        self.cursor.setShape(Qt.CursorShape.ArrowCursor)\r\n        QApplication.setOverrideCursor(self.cursor)\r\n        print(self.cursor.shape())'''\r\n\r\n    def resizeEvent(self, event):\r\n        '''if self.contentsRect().width() > self.contentsRect().height():\r\n            new_size = self.image.scaled(self.height(), self.height())\r\n        else:\r\n            new_size = self.image.scaled(self.width(), self.width())'''\r\n        self.image = self.image.scaled(self.width(), self.height())\r\n\r\n\r\n    def initBoard(self):\r\n        '''initiates board'''\r\n        self.timer = QBasicTimer()  # create a timer for the game\r\n        self.isStarted = False  # game is not currently started\r\n\r\n        '''#self.start()                # start the game which will start the timer\r\n        #0 représente une case vide, 1 représente les noirs (ce joueur commence) et 2 représente les blancs\r\n        self.a = 0\r\n        self.b = 0\r\n        self.c = 0\r\n        self.d = 0\r\n        self.e = 0\r\n        self.f = 0\r\n        self.g = 0\r\n        self.h = 0\r\n        self.i = 0\r\n        self.j = 0\r\n        self.k = 0\r\n        self.l = 0\r\n        self.m = 0\r\n        self.n = 0\r\n        self.o = 0\r\n        self.p = 0\r\n        self.q = 0\r\n        self.r = 0\r\n        self.s = 0\r\n        self.t = 0\r\n        self.u = 0\r\n        self.v = 0\r\n        self.w = 0\r\n        self.x = 0\r\n        self.y = 0\r\n        self.z = 0\r\n        self.ab = 0\r\n        self.ac = 0\r\n        self.ad = 0\r\n        self.ae = 0\r\n        self.af = 0\r\n        self.ag = 0\r\n        self.ah = 0\r\n        self.ai = 0\r\n        self.aj = 0\r\n        self.ak = 0\r\n        self.al = 0\r\n        self.am = 0\r\n        self.an = 0\r\n        self.ao = 0\r\n        self.ap = 0\r\n        self.aq = 0\r\n        self.ar = 0\r\n        self.ay = 0\r\n        self.at = 0\r\n        self.au = 0\r\n        self.av = 0\r\n        self.aw = 0\r\n        self.ax = 0\r\n        #il y'a 49 intersections donc on doit créer un tableau avc 49 cases et le remplir de 0, 1 ou 2\r\n        [self.a, self.b, self.c, self.d, self.e, self.f, self.g],\r\n          [self.h, self.i, self.j, self.k, self.l, self.m, self.n],\r\n          [self.o, self.p, self.q, self.r, self.s, self.t, self.u],\r\n          [self.v, self.w, self.x, self.y, self.z, self.ab, self.ac],\r\n          [self.ad, self.ae, self.af, self.ag, self.ah, self.ai, self.aj],\r\n          [self.ak, self.al, self.am, self.an, self.ao, self.ap, self.aq],\r\n          [self.ar, self.ay, self.at, self.au, self.av, self.aw, self.ax],'''\r\n        self.boardArray = self.go.gameLogic.boardState  # TODO - create a 2d int/Piece array to store the state of the game\r\n        self.printBoardArray()  # TODO - uncomment this method after creating the array above\r\n\r\n    def printBoardArray(self):\r\n        '''prints the boardArray in an attractive way'''\r\n        print(\"boardArray:\")\r\n        print('\\n'.join(['\\t'.join([str(cell) for cell in row]) for row in self.boardArray]))\r\n        '''\r\n        if gameLogic.boardState.owner == 1\r\n            painter.setPen(QPen(Qt.GlobalColor.white, self.brushSize))\r\n            painter.setBrush(QBrush(Qt.GlobalColor.white, Qt.BrushStyle.SolidPattern))\r\n            painter.drawEllipse(int(self.mouseX)-20, int(self.mouseY)-20, 50, 50)\r\n            self.update()\r\n        elif gameLogic.boardState.owner == 2\r\n            same in black..  \r\n\r\n        '''\r\n\r\n    def mousePosToColRow(self, event):\r\n        '''convert the mouse click event to a row and column'''\r\n\r\n    def squareWidth(self):\r\n        '''returns the width of one square in the board'''\r\n        return self.contentsRect().width() / self.boardWidth\r\n\r\n    def squareHeight(self):\r\n        '''returns the height of one square of the board'''\r\n        return self.contentsRect().height() / self.boardHeight\r\n\r\n    def start(self):\r\n        '''starts game'''\r\n        self.isStarted = True  # set the boolean which determines if the game has started to TRUE\r\n        self.resetGame()  # reset the game\r\n        self.timer.start(self.timerSpeed, self)  # start the timer with the correct speed\r\n        print(\"start () - timer is started\")\r\n\r\n    def timerEvent(self, event):\r\n        '''this event is automatically called when the timer is updated. based on the timerSpeed variable '''\r\n        # TODO adapt this code to handle your timers\r\n        if event.timerId() == self.timer.timerId():  # if the timer that has 'ticked' is the one in this class\r\n            if self.counter == 1:\r\n                print(\"Game over\")\r\n                self.timer.stop()\r\n            self.counter -= 1\r\n            print('timerEvent()', self.counter)\r\n            self.updateTimerSignal.emit(self.counter)\r\n            # self.go.scoreBoard.setTimeRemaining(self.counter)\r\n        else:\r\n            super(Board, self).timerEvent(event)  # if we do not handle an event we should pass it to the super\r\n            # class for handling\r\n\r\n    def paintEvent(self, event):\r\n        '''paints the board and the pieces of the game'''\r\n        painter = QPainter(self)\r\n        painter.drawPixmap(QPoint(), self.image)\r\n\r\n    def mousePressEvent(self, event):\r\n        '''this event is automatically called when the mouse is pressed'''\r\n        clickLoc = \"click location [\" + str(event.position().x()) + \",\" + str(\r\n            event.position().y()) + \"]\"  # the location where a mouse click was registered\r\n        print(\"mousePressEvent() - \" + clickLoc)\r\n        self.mouseX = event.position().x()\r\n        self.mouseY = event.position().y()\r\n        print(self.mouseX, self.mouseY)\r\n        # TODO you could call some game logic here\r\n        self.clickLocationSignal.emit(clickLoc)\r\n        # self.drawPieces()\r\n        self.tryMove()\r\n\r\n    def resetGame(self):\r\n        '''clears pieces from the board'''\r\n        # TODO write code to reset game\r\n        '''\r\n        self.image = QPixmap(\"./icons/Board.png\")\r\n        width = self.width()  # get the width of the current QImage in your application\r\n        height = self.height()  # get the height of the current QImage in your application\r\n        self.image = self.image.scaled(width, height)\r\n        '''\r\n\r\n    def tryMove(self):\r\n        '''tries to move a piece'''\r\n        if self.draw:\r\n            for newX in range(54, 600, 90):\r\n                for newY in range(64, 800, 110):\r\n                    if (self.mouseX - newX) ** 2 + (self.mouseY - newY) ** 2 <= 30.0 ** 2:\r\n                        # self.cursor.setShape(Qt.CursorShape.PointingHandCursor)\r\n                        # QApplication.setOverrideCursor(self.cursor)\r\n                        col, row = self.pixelToInt(newX, newY)\r\n                        if self.go.gameLogic.placeForPlayer[self.go.gameLogic.currentPlayer - 1][col][row]:\r\n                            self.drawPieces(newX, newY, col, row)\r\n                            # self.pixelToInt(newX, newY)  # affiche la colonne et la ligne de la pièce\r\n                            if self.go.scoreBoard.currentTurn == \"Player 1\":\r\n                                self.go.scoreBoard.currentTurn = \"Player 2\"\r\n                            else:\r\n                                self.go.scoreBoard.currentTurn = \"Player 1\"\r\n                            self.go.scoreBoard.updateUi()\r\n        else:\r\n            for newX in range(54, 774, 90):\r\n                for newY in range(64, 944, 110):\r\n                    if (self.mouseX - newX) ** 2 + (self.mouseY - newY) ** 2 <= 30.0 ** 2:\r\n                        self.deletePiece(newX, newY)\r\n        '''\r\n        Equation d'un cercle : (x−h)²+(y−k)²=r².\r\n        Si newX et newY vérifie l'équation alors le point est dans la zone\r\n        h : commence à 146 puis on ajoute 90 à chaque fois qu'on se décale sur la droite\r\n        y : commence à 176 puis on ajoute 110 à chaque fois qu'on se décale vers le bas\r\n        '''\r\n\r\n    def pixelToInt(self, mouseX, mouseY):\r\n        countC = -1\r\n        countR = -1\r\n        finalC = -1\r\n        finalR = -1\r\n        for i in range(54, 600, 90):\r\n            countC += 1\r\n            if i == mouseX:\r\n                finalC = countC\r\n\r\n        for j in range(64, 800, 110):\r\n            countR += 1\r\n            if j == mouseY:\r\n                finalR = countR\r\n        print(finalC, finalR)\r\n        return finalC, finalR\r\n\r\n    def drawBoardSquares(self, painter):\r\n        '''draw all the square on the board'''\r\n        self.brushSize = 3\r\n        self.brushColor = Qt.GlobalColor.black\r\n        painter.setPen(QPen(self.brushColor, self.brushSize))\r\n        painter.fillRect(QRect(0, 0, self.contentsRect().width(), self.contentsRect().height()),\r\n                         self.go.backgroundColor)\r\n\r\n        if self.squareWidth() <= self.squareHeight():\r\n            squareSide = self.squareWidth()\r\n        else:\r\n            squareSide = self.squareHeight()\r\n        for row in range(0, Board.boardHeight):\r\n            for col in range(0, Board.boardWidth):\r\n                painter.save()\r\n                colTransformation = squareSide * 0.5 + squareSide * col\r\n                rowTransformation = squareSide * 0.5 + squareSide * row\r\n                painter.fillRect(\r\n                    QRect(int(colTransformation), int(rowTransformation), int(squareSide), int(squareSide)),\r\n                    QColor(\"#E0BD6B\"))\r\n                painter.drawRect(\r\n                    QRect(int(colTransformation), int(rowTransformation), int(squareSide), int(squareSide)))\r\n                painter.restore()\r\n                self.brushColor = self.go.backgroundColor\r\n\r\n        # TODO set the default colour of the brush\r\n        # draw settings (default)\r\n        \"\"\"self.drawing = False\r\n        self.brushSize = 3\r\n        self.brushColor = Qt.GlobalColor.black  # documentation: https://doc.qt.io/qt-6/qt.html#GlobalColor-enum\r\n        for row in range(0, Board.boardHeight):\r\n            for col in range (0, Board.boardWidth):\r\n                row += 1\r\n                col += 1\r\n                painter.drawRect(row, col, 100, 100)\r\n\r\n                painter.save()\r\n                colTransformation = self.squareWidth()* col # TODO set this value equal the transformation in the column direction\r\n                rowTransformation = 0                       # TODO set this value equal the transformation in the row direction\r\n                painter.translate(colTransformation,rowTransformation)\r\n                painter.fillRect(colTransformation, rowTransformation)     # TODO provide the required arguments\r\n                painter.restore()\r\n                # TODO change the colour of the brush so that a checkered board is drawn\r\n                self.brushColor = Qt.GlobalColor.white\"\"\"\r\n\r\n    def drawPieces(self, newX, newY, col, row):\r\n        '''draw the pieces on the board'''\r\n        self.brushSize = 5\r\n        painter = QPainter(self.image)\r\n        if self.go.scoreBoard.currentTurn == \"Player 1\":\r\n            painter.setPen(QPen(Qt.GlobalColor.black, self.brushSize))\r\n            painter.setBrush(QBrush(Qt.GlobalColor.black, Qt.BrushStyle.SolidPattern))\r\n            painter.drawEllipse(int(newX) - 20, int(newY) - 20, 50, 50)\r\n            self.update()\r\n            self.go.gameLogic.update(Piece(col, row, self.go.gameLogic.currentPlayer))\r\n            self.updateTheBoard(painter)\r\n        else:\r\n            painter.setPen(QPen(Qt.GlobalColor.white, self.brushSize))\r\n            painter.setBrush(QBrush(Qt.GlobalColor.white, Qt.BrushStyle.SolidPattern))\r\n            painter.drawEllipse(int(newX) - 20, int(newY) - 20, 50, 50)\r\n            self.update()\r\n            self.go.gameLogic.update(Piece(col, row, self.go.gameLogic.currentPlayer))\r\n            self.updateTheBoard(painter)\r\n\r\n        # painter.drawEllipse(125, 155, 50, 50)\r\n        '''colour = Qt.GlobalColor.transparent # empty square could be modeled with transparent pieces\r\n        for row in range(0, len(self.boardArray)):\r\n            for col in range(0, len(self.boardArray[0])):\r\n                painter.save()\r\n                painter.translate()\r\n\r\n                # TODO draw some the pieces as ellipses\r\n                # TODO choose your colour and set the painter brush to the correct colour\r\n                # draw settings (default)\r\n                self.drawing = False\r\n                self.brushSize = 3\r\n                colour = Qt.GlobalColor.black\r\n                radius = self.squareWidth() / 4\r\n                center = QPointF(radius, radius)\r\n                painter.drawEllipse(center, radius, radius)\r\n                painter.restore()'''\r\n\r\n    def deletePiece(self, newX, newY):\r\n        '''delete a piece on the board'''\r\n        self.brushSize = 5\r\n        painter = QPainter(self.image)\r\n        painter.setPen(QPen(Qt.GlobalColor.red, self.brushSize))\r\n        painter.drawLine(int(newX) - 20, int(newY) - 20, int(newX) + 40, int(newY) + 40)\r\n        painter.drawLine(int(newX) - 20, int(newY) + 40, int(newX) + 40, int(newY) - 20)\r\n        self.update()\r\n\r\n    def updateTheBoard(self, painter):\r\n        self.imageOrigin = self.imageOrigin.scaled(self.width(), self.height())\r\n        painter.drawPixmap(QPoint(), self.imageOrigin)\r\n        self.brushSize = 5\r\n        row = -1\r\n        for newX in range(54, 600, 90):\r\n            col = -1\r\n            row = row + 1\r\n            for newY in range(64, 800, 110):\r\n                col = col + 1\r\n                if self.go.gameLogic.boardState[row][col].owner != 0:\r\n                    if self.go.gameLogic.boardState[row][col].owner == 1:\r\n                        painter.setPen(QPen(Qt.GlobalColor.black, self.brushSize))\r\n                        painter.setBrush(QBrush(Qt.GlobalColor.black, Qt.BrushStyle.SolidPattern))\r\n                    else:\r\n                        painter.setPen(QPen(Qt.GlobalColor.white, self.brushSize))\r\n                        painter.setBrush(QBrush(Qt.GlobalColor.white, Qt.BrushStyle.SolidPattern))\r\n                    painter.drawEllipse(int(newX) - 20, int(newY) - 20, 50, 50)\r\n                    self.update()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py
--- a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
+++ b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py	(date 1670776692229)
@@ -28,6 +28,7 @@
         self.setLayout(self.mainLayout)
         self.resize(800, 1000)
         self.draw = True
+        self.count = 0
         '''self.cursor = QCursor()
         # self.image.setCursor(self.cursor)
         #self.cursor.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
@@ -172,7 +173,7 @@
         self.mouseY = event.position().y()
         print(self.mouseX, self.mouseY)
         # TODO you could call some game logic here
-        self.clickLocationSignal.emit(clickLoc)
+        #self.clickLocationSignal.emit(clickLoc) #inutile car on n'affiche plus la posiition du click
         # self.drawPieces()
         self.tryMove()
 
@@ -188,6 +189,7 @@
 
     def tryMove(self):
         '''tries to move a piece'''
+        self.count = 0
         if self.draw:
             for newX in range(54, 600, 90):
                 for newY in range(64, 800, 110):
Index: studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from pieceGroup import PieceGroup\r\nfrom piece import Piece\r\n\r\n\r\nclass GameLogic:\r\n    # The pieces are undeletable and uncreable, it is only their owner who will change :\r\n    # 0 for nothing, 1 for player 1 and 2 for player 2\r\n\r\n    print(\"Game Logic Object Created\")\r\n\r\n    # TODO add code here to manage the logic of your game\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.dimensionBoard = 7\r\n        self.scores = [0, 0]\r\n\r\n        self.boardState = []\r\n        for i in range(0, self.dimensionBoard):\r\n            array = [0] * self.dimensionBoard\r\n            self.boardState.append(array)\r\n        for i in range(0, self.dimensionBoard):\r\n            for j in range(0, self.dimensionBoard):\r\n                self.boardState[i][j] = Piece(i, j, 0)\r\n        self.placeForPlayer = []\r\n        for k in range(0, 2):\r\n            array2 = []\r\n            for i in range(0, self.dimensionBoard):\r\n                array = [True] * self.dimensionBoard\r\n                array2.append(array)\r\n            self.placeForPlayer.append(array2)\r\n        self.currentPlayer = 1\r\n        self.groups = [[], []]\r\n        self.captured = [0, 0]\r\n        self.previousBoards = []\r\n\r\n    def update(self, piece):\r\n        print(\"new move !!!!!!!!!!!!!!!!!\")\r\n\r\n        # Create some variables to check the state of the board at every updates\r\n        neighbour = 0\r\n        left = False\r\n        right = False\r\n        top = False\r\n        bottom = False\r\n        suicideRule = []\r\n        boardOwners = []\r\n        for i in range(0, self.dimensionBoard):\r\n            array = [0]*self.dimensionBoard\r\n            boardOwners.append(array)\r\n\r\n        aa = []\r\n        print(\"before\")\r\n        for i in range(0, self.dimensionBoard):\r\n            array = [0] * self.dimensionBoard\r\n            aa.append(array)\r\n        for i in range(0, 7):\r\n            for j in range(0, 7):\r\n                aa[i][j] = self.boardState[i][j].owner\r\n        print(aa)\r\n\r\n        self.boardState[piece.x][piece.y].owner = self.currentPlayer  # Change the owner of the piece (add the new piece to the board)\r\n        print(\"position gamelogic:\", piece.x, piece.y)\r\n\r\n        # Save the owners for the koRule\r\n        for i in self.boardState:\r\n            for j in i:\r\n                boardOwners[j.x][j.y] = j.owner\r\n\r\n        aa = []\r\n        print(\"just after the placement of the piece\")\r\n        for i in range(0, self.dimensionBoard):\r\n            array = [0] * self.dimensionBoard\r\n            aa.append(array)\r\n        for i in range(0, 7):\r\n            for j in range(0, 7):\r\n                aa[i][j] = self.boardState[i][j].owner\r\n        print(aa)\r\n\r\n        temporaryPreviousBoard = boardOwners\r\n\r\n        # Test if this new piece is near an existing piece (group)\r\n        if piece.x != 0:\r\n            if self.boardState[piece.x - 1][piece.y].owner == self.currentPlayer:\r\n                neighbour = neighbour + 1\r\n                left = True\r\n        if piece.x != self.dimensionBoard - 1:\r\n            if self.boardState[piece.x + 1][piece.y].owner == self.currentPlayer:\r\n                neighbour = neighbour + 1\r\n                right = True\r\n        if piece.y != 0:\r\n            if self.boardState[piece.x][piece.y - 1].owner == self.currentPlayer:\r\n                neighbour = neighbour + 1\r\n                top = True\r\n        if piece.y != self.dimensionBoard - 1:\r\n            if self.boardState[piece.x][piece.y + 1].owner == self.currentPlayer:\r\n                neighbour = neighbour + 1\r\n                bottom = True\r\n        #print(neighbour)\r\n\r\n        # If the piece is near an existed group, add it to it\r\n        if neighbour > 0:\r\n            addAble = True\r\n            for i in self.groups[self.currentPlayer - 1]:\r\n                #print(i.pieces)\r\n                #print(self.boardState[piece.x - 1][piece.y])\r\n                #print(self.boardState[1][piece.y])\r\n                if (self.boardState[piece.x - 1][piece.y] in i.pieces or self.boardState[piece.x + 1][piece.y] in i.pieces or self.boardState[piece.x][piece.y - 1] in i.pieces or self.boardState[piece.x][piece.y + 1] in i.pieces) and addAble:\r\n                    print(\"dedans\")\r\n                    addAble = False\r\n                    i.addPiece(self.boardState[piece.x][piece.y])\r\n\r\n            # Fusion 2 groups if a piece makes the link between them\r\n            if neighbour > 1:\r\n                fusions = []\r\n                if top:\r\n                    for i in self.groups[self.currentPlayer - 1]:\r\n                        if self.boardState[piece.x][piece.y - 1] in i.pieces:\r\n                            fusions.append(i)\r\n                if bottom:\r\n                    for i in self.groups[self.currentPlayer - 1]:\r\n                        if self.boardState[piece.x][piece.y + 1] in i.pieces:\r\n                            fusions.append(i)\r\n                if left:\r\n                    for i in self.groups[self.currentPlayer - 1]:\r\n                        if self.boardState[piece.x - 1][piece.y] in i.pieces:\r\n                            fusions.append(i)\r\n                if right:\r\n                    for i in self.groups[self.currentPlayer - 1]:\r\n                        if self.boardState[piece.x + 1][piece.y] in i.pieces:\r\n                            fusions.append(i)\r\n\r\n                fusions = set(fusions)\r\n                fusions = list(fusions)\r\n                print(fusions[0])\r\n                #ON PEUT PAS INDEXER UN SET !!!!!!!\r\n                for i in range(1, len(fusions)):\r\n                    for j in fusions[i].pieces:\r\n                        fusions[0].addPiece(j)\r\n                    self.groups[self.currentPlayer - 1].remove(fusions[i])\r\n\r\n        # If there is no groups near the new piece, create a new piece group\r\n        else:\r\n            self.groups[self.currentPlayer - 1].append(PieceGroup(self.boardState[piece.x][piece.y]))\r\n\r\n        # Reset the liberties of each piece groups for each player\r\n        for k in range(0, 2):\r\n            print(\"GROUPS of :\", k)\r\n            print(\"Number of groups:\", len(self.groups[k]))\r\n            for i in self.groups[k]:\r\n                print(\"pieces in this group:\", len(i.pieces))\r\n                for j in i.pieces:\r\n                    print(\"position of the piece:\", j.x, j.y)\r\n                i.liberties = 0\r\n                libertiescoord = []\r\n                for j in i.pieces:\r\n                    if j.x != 0:\r\n                        if self.boardState[j.x - 1][j.y].owner == 0:\r\n                            if [j.x - 1, j.y] not in libertiescoord:\r\n                                libertiescoord.append([j.x - 1, j.y])\r\n                                i.liberties = i.liberties + 1\r\n                    if j.x != self.dimensionBoard - 1:\r\n                        if self.boardState[j.x + 1][j.y].owner == 0:\r\n                            if [j.x + 1, j.y] not in libertiescoord:\r\n                                libertiescoord.append([j.x + 1, j.y])\r\n                                i.liberties = i.liberties + 1\r\n                    if j.y != 0:\r\n                        if self.boardState[j.x][j.y - 1].owner == 0:\r\n                            if [j.x, j.y - 1] not in libertiescoord:\r\n                                libertiescoord.append([j.x, j.y - 1])\r\n                                i.liberties = i.liberties + 1\r\n                    if j.y != self.dimensionBoard - 1:\r\n                        if self.boardState[j.x][j.y + 1].owner == 0:\r\n                            if [j.x, j.y + 1] not in libertiescoord:\r\n                                libertiescoord.append([j.x, j.y + 1])\r\n                                i.liberties = i.liberties + 1\r\n\r\n                # If liberties goes to 1, the player can't play to this last liberties if this place blocks all liberties (KO rule)\r\n                print(\"pieces in the grid: \",i.pieces[0].x, i.pieces[0].y,\"liberties: \",i.liberties)\r\n                if i.liberties == 1:\r\n                    playable = False\r\n                    toCheck = [libertiescoord[0][0], libertiescoord[0][1]]\r\n                    if toCheck[0] != 0:\r\n                        if self.boardState[toCheck[0] - 1][toCheck[1]].owner == 0:\r\n                            playable = True\r\n                    if toCheck[0] != self.dimensionBoard - 1:\r\n                        if self.boardState[toCheck[0] + 1][toCheck[1]].owner == 0:\r\n                            playable = True\r\n                    if toCheck[1] != 0:\r\n                        if self.boardState[toCheck[0]][toCheck[1] - 1].owner == 0:\r\n                            playable = True\r\n                    if toCheck[1] != self.dimensionBoard - 1:\r\n                        if self.boardState[toCheck[0]][toCheck[1] + 1].owner == 0:\r\n                            playable = True\r\n                    if not playable:\r\n                        suicideRule.append([k, toCheck[0]], toCheck[1])\r\n\r\n                # If liberties goes to 0, the other player get the pieces and the group is deleted\r\n                if i.liberties == 0:\r\n                    self.captured[(k + 1) % 2] = self.captured[(k + 1) % 2] + len(i.pieces)\r\n                    for j in i.pieces:\r\n                        j.owner = 0\r\n                    self.groups[k].remove(i)\r\n                    print(\"deleted\")\r\n                    print(self.groups[k][0].pieces[0].x, self.groups[k][0].pieces[0].y)\r\n\r\n        # Update the list of position where the players can play\r\n        self.placeForPlayer = []\r\n        for k in range(0, 2):\r\n            array2 = []\r\n            for i in range(0, self.dimensionBoard):\r\n                array = [True] * self.dimensionBoard\r\n                array2.append(array)\r\n            self.placeForPlayer.append(array2)\r\n        \"\"\"\r\n        aa = []\r\n        print(\"After everything\")\r\n        for i in range(0, self.dimensionBoard):\r\n            array = [0] * self.dimensionBoard\r\n            aa.append(array)\r\n        for i in range(0, self.dimensionBoard):\r\n            for j in range(0, self.dimensionBoard):\r\n                aa[i][j] = self.boardState[i][j].owner\r\n        print(aa)\"\"\"\r\n\r\n        for i in self.boardState:\r\n            for j in i:\r\n                if j.owner != 0:\r\n                    for k in range(0, 2):\r\n                        self.placeForPlayer[k][j.x][j.y] = False\r\n        \"\"\"print(\"place For players after already placed:\")\r\n        print(self.placeForPlayer)\"\"\"\r\n\r\n        # Disable positions for SuicidRule\r\n        for i in suicideRule:\r\n            self.placeForPlayer[i[0]][i[1]][i[2]] = False\r\n\r\n        for k in range(0, 2):\r\n            for i in range(0, self.dimensionBoard):\r\n                for j in range(0, self.dimensionBoard):\r\n                    if self.placeForPlayer[k][i][j]:\r\n                        enemies = 0\r\n                        if i != 0:\r\n                            if self.boardState[i - 1][j].owner == (k + 1) % 2 + 1:\r\n                                enemies = enemies + 1\r\n                        else:\r\n                            enemies = enemies + 1\r\n                        if i != self.dimensionBoard - 1:\r\n                            if self.boardState[i + 1][j].owner == (k + 1) % 2 + 1:\r\n                                enemies = enemies + 1\r\n                        else:\r\n                            enemies = enemies + 1\r\n                        if j != 0:\r\n                            if self.boardState[i][j - 1].owner == (k + 1) % 2 + 1:\r\n                                enemies = enemies + 1\r\n                        else:\r\n                            enemies = enemies + 1\r\n                        if j != self.dimensionBoard - 1:\r\n                            if self.boardState[i][j + 1].owner == (k + 1) % 2 + 1:\r\n                                enemies = enemies + 1\r\n                        else:\r\n                            enemies = enemies + 1\r\n                        if enemies == 4:\r\n                            self.placeForPlayer[k][i][j] = False\r\n\r\n        \"\"\"print(\"place For players after suicide rule:\")\r\n        print(self.placeForPlayer)\"\"\"\r\n        # Test the futures enbale positions for koRule\r\n        for k in range(0, 2):\r\n            for i in range(0, self.dimensionBoard):\r\n                for j in range(0, self.dimensionBoard):\r\n                    if self.placeForPlayer[k][i][j]:\r\n                        boardOwners[i][j] = k + 1\r\n                        if boardOwners in self.previousBoards:\r\n                            self.placeForPlayer[k][i][j] = False\r\n                        boardOwners[i][j] = 0\r\n        self.previousBoards.append(temporaryPreviousBoard)\r\n        \"\"\"print(\"place For players after ko rule:\")\r\n        print(self.placeForPlayer)\"\"\"\r\n        self.changePlayer()\r\n\r\n    def changePlayer(self):  # Change the current player\r\n        if self.currentPlayer == 1:\r\n            self.currentPlayer = 2\r\n        else:\r\n            self.currentPlayer = 1\r\n\r\n    def scoreCount(self):  # AVANT D'APPELER CETTE FONCTION, FAIRE RETIRER DU PLATEAU LES PIECES DE TROP PAR LES JOUEURS !!!\r\n        voidGroups = []\r\n        for i in range(0, self.dimensionBoard):\r\n            for j in range(0, self.dimensionBoard):\r\n                neighbour = 0\r\n                top = False\r\n                left = False\r\n                if self.boardState[i][j].owner == 0:\r\n                    if i == 0 and j == 0:\r\n                        voidGroups.append(PieceGroup(self.boardState[i][j]))\r\n                    elif i == 0:\r\n                        if self.boardState[i][j-1].owner != 0:\r\n                            voidGroups.append(PieceGroup(self.boardState[i][j]))\r\n                        else:\r\n                            for k in voidGroups:\r\n                                if k.pieces.count(self.boardState[i][j-1]) != 0:\r\n                                    k.addPiece(self.boardState[i][j])\r\n                    elif j == 0:\r\n                        if self.boardState[i-1][j].owner != 0:\r\n                            voidGroups.append(PieceGroup(self.boardState[i][j]))\r\n                        else:\r\n                            for k in voidGroups:\r\n                                if k.pieces.count(self.boardState[i-1][j]) != 0:\r\n                                    k.addPiece(self.boardState[i][j])\r\n                    else:\r\n                        if self.boardState[i-1][j].owner != 0:\r\n                            neighbour = neighbour + 1\r\n                            top = True\r\n                        if self.boardState[i][j-1].owner != 0:\r\n                            neighbour = neighbour + 1\r\n                            left = True\r\n                        if neighbour >= 1:\r\n                            if top:\r\n                                for k in voidGroups:\r\n                                    if k.pieces.count(self.boardState[i-1][j]) != 0:\r\n                                        k.addPiece(self.boardState[i][j])\r\n                            else:\r\n                                for k in voidGroups:\r\n                                    if k.pieces.count(self.boardState[i][j-1]) != 0:\r\n                                        k.addPiece(self.boardState[i][j])\r\n                            if neighbour>1:\r\n                                for k in voidGroups:\r\n                                    if k.pieces.count(self.boardState[i-1][j]) != 0:\r\n                                        for l in voidGroups:\r\n                                            if l.pieces.count(self.boardState[i][j-1]) != 0:\r\n                                                for m in l.pieces:\r\n                                                    k.addPiece(m)\r\n                                                voidGroups.remove(l)\r\n                        else:\r\n                            voidGroups.append(PieceGroup(self.boardState[i][j]))\r\n\r\n        for i in voidGroups:\r\n            for j in i.pieces:\r\n                if j.x != 0:\r\n                    if self.boardState[j.x-1][j.y].owner != 0:\r\n                        i.owners[self.boardState[j.x-1][j.y].owner-1] = i.owners[self.boardState[j.x-1][j.y].owner-1] + 1\r\n                if j.x != self.boardState - 1:\r\n                    if self.boardState[j.x+1][j.y].owner != 0:\r\n                        i.owners[self.boardState[j.x+1][j.y].owner-1] = i.owners[self.boardState[j.x+1][j.y].owner-1] + 1\r\n                if j.y != 0:\r\n                    if self.boardState[j.x][j.y-1].owner != 0:\r\n                        i.owners[self.boardState[j.x][j.y-1].owner-1] = i.owners[self.boardState[j.x][j.y-1].owner-1] + 1\r\n                if j.y != self.boardState - 1:\r\n                    if self.boardState[j.x][j.y+1].owner != 0:\r\n                        i.owners[self.boardState[j.x][j.y+1].owner-1] = i.owners[self.boardState[j.x][j.y+1].owner-1] + 1\r\n\r\n        for i in voidGroups:\r\n            if i.owners[1] == 0:\r\n                self.scores[0] = self.scores[0] + len(i.pieces)\r\n            elif i.owners[0] == 0:\r\n                self.scores[1] = self.scores[1] + len(i.pieces)\r\n\r\n        for i in self.boardState:\r\n            for j in i:\r\n                if j.owner == 1:\r\n                    self.scores[0] = self.scores[0] + 1\r\n                elif j.owner == 2:\r\n                    self.scores[1] = self.scores[1] + 1\r\n\r\n        self.scores[0] = self.scores[0] - self.captured[1]\r\n        self.scores[1] = self.scores[1] - self.captured[0]\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py
--- a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
+++ b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py	(date 1670693423110)
@@ -366,4 +366,3 @@
         self.scores[0] = self.scores[0] - self.captured[1]
         self.scores[1] = self.scores[1] - self.captured[0]
 
-
Index: studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/go.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from PyQt6.QtWidgets import QMainWindow, QHBoxLayout, QWidget,QLayout\r\nfrom PyQt6.QtCore import Qt\r\nfrom PyQt6.QtGui import QIcon\r\nfrom board import Board\r\nfrom score_board import ScoreBoard\r\nfrom game_logic import GameLogic\r\nfrom endGameWindow import EndGameWindow\r\n\r\nclass Go(QMainWindow):\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.initUI()\r\n\r\n    def getBoard(self):\r\n        return self.board\r\n\r\n    def getScoreBoard(self):\r\n        return self.scoreBoard\r\n\r\n    def initUI(self):\r\n        '''initiates application UI'''\r\n        self.gameLogic = GameLogic()\r\n        self.scoreBoard = ScoreBoard(self)\r\n        self.board = Board(self)\r\n        self.endGameWindow = EndGameWindow(self)\r\n        #self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.scoreBoard)\r\n        self.myScoreBoard = QHBoxLayout()\r\n        self.myScoreBoard.addWidget(self.board, 6)\r\n        self.myScoreBoard.addWidget(self.scoreBoard, 1)\r\n        mainWidget = QWidget()\r\n        mainWidget.setLayout(self.myScoreBoard)\r\n        self.setCentralWidget(mainWidget)\r\n        self.scoreBoard.make_connection(self.board)\r\n\r\n        self.resize(850, 850)\r\n        #self.center()\r\n        self.setStyleSheet(\"background-color: light grey\")\r\n        self.setWindowTitle(\"GroupProject - Go - HGP-FT02\")\r\n        self.setWindowIcon(\r\n            QIcon(\"./icons/logo.png\"))\r\n        self.show()\r\n\r\n    def showEndWindow(self):\r\n        self.hide()\r\n        self.endGameWindow.show()\r\n    def center(self):\r\n        '''centers the window on the screen'''\r\n        gr = self.frameGeometry()\r\n        screen = self.screen().availableGeometry().center()\r\n\r\n        gr.moveCenter(screen)\r\n        self.move(gr.topLeft())\r\n        #size = self.geometry()\r\n        #self.move((screen.width() - size.width()) / 2,(screen.height() - size.height()) / 2)\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/go.py b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/go.py
--- a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/go.py	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
+++ b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/go.py	(date 1670781120928)
@@ -38,7 +38,7 @@
         self.setStyleSheet("background-color: light grey")
         self.setWindowTitle("GroupProject - Go - HGP-FT02")
         self.setWindowIcon(
-            QIcon("./icons/logo.png"))
+            QIcon("./icons/go.png"))
         self.show()
 
     def showEndWindow(self):
Index: studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from PyQt6.QtWidgets import QApplication, QDockWidget, QGridLayout, QMessageBox, QGroupBox, QMenuBar, QProgressBar, QHBoxLayout, QVBoxLayout, QPushButton, QWidget, QLabel, QScrollArea\r\nfrom PyQt6.QtCore import pyqtSlot, QSize, Qt, QBasicTimer\r\nfrom PyQt6.QtGui import QIcon, QAction, QPixmap, QCursor, QPen, QPainter, QFont\r\nfrom board import Board\r\nclass ScoreBoard(QWidget):\r\n    '''# base the score_board on a QWidget'''\r\n\r\n    def __init__(self, go):\r\n        super().__init__()\r\n        self.go = go\r\n        self.initUI()\r\n\r\n\r\n    def initUI(self):\r\n        '''initiates ScoreBoard UI'''\r\n\r\n        self.vboxMain = QVBoxLayout()\r\n        self.firstTimer = False\r\n        self.firstSkip = False\r\n\r\n        # Here we create 3 GroupBoxs to hold other widgets : one for Player 1, one for Player 2 and one for other things\r\n        # needed to play the game.\r\n        self.mainWidgetB = QGroupBox()\r\n        self.mainWidgetB.setTitle(\"Player 1 - Black Stones\")\r\n        '''self.mainWidgetB.setStyleSheet(\"color: white;\"\r\n                                       \"background-color: black\")'''\r\n\r\n        self.mainWidgetW = QGroupBox()\r\n        self.mainWidgetW.setTitle(\"Player 2 - White Stones\")\r\n        '''self.mainWidgetW.setStyleSheet(\"color: black;\"\r\n                                       \"background-color: white\")'''\r\n        self.mainWidgetM = QGroupBox()\r\n        self.mainWidgetM.setTitle(\"Others\")\r\n        self.mainWidgetM.setStyleSheet(\"color: black;\"\r\n                                       \"background-color: grey\")\r\n\r\n        self.mainLayoutB = QVBoxLayout()\r\n        self.mainLayoutW = QVBoxLayout()\r\n        self.mainLayoutM = QVBoxLayout()\r\n\r\n        # Here we create all the Widgets needed for the game (label, button, timer...).\r\n        self.label_timeRemainingW = QLabel(\"Time remaining: \")\r\n        self.label_timeRemainingB = QLabel(\"Time remaining: \")\r\n        self.currentTurn = \"Player 1\"\r\n        self.playerLabel = QLabel(\"Current Turn: \" + self.currentTurn)\r\n        self.playerLabel.setStyleSheet(\"font-weight: bold\")\r\n        self.mainLayoutM.addWidget(self.playerLabel)\r\n        self.captureW = QLabel(\"Captures : \" + str(self.go.gameLogic.captured[1]))\r\n        self.captureB= QLabel(\"Captures : \" + str(self.go.gameLogic.captured[0]))\r\n        self.mainLayoutW.addWidget(self.captureW)\r\n        self.mainLayoutB.addWidget(self.captureB)\r\n        self.matchButton = QPushButton(\"Match Details\", self)\r\n        self.matchButton.clicked.connect(self.matchDetails)\r\n        self.matchButton.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        resetGame = QPushButton('Reset Game')\r\n        resetGame.clicked.connect(self.clear)\r\n        resetGame.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        self.mainLayoutM.addWidget(self.matchButton)\r\n        self.mainLayoutM.addWidget(resetGame)\r\n        self.timerButtonB = QPushButton('2 Minute Timer', self)\r\n        self.timerButtonW = QPushButton('2 Minute Timer', self)\r\n        self.timerButtonB.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        self.timerButtonW.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        self.timerButtonB.clicked.connect(self.buttonTimerB_clicked)\r\n        self.timerButtonW.clicked.connect(self.buttonTimerW_clicked)\r\n        self.pbarB = QProgressBar(self)\r\n        self.pbarB.setMaximum(120)\r\n        self.pbarB.setTextVisible(False)\r\n        self.pbarW = QProgressBar(self)\r\n        self.pbarW.setMaximum(120)\r\n        self.pbarW.setTextVisible(False)\r\n        self.stepB = 0\r\n        self.stepW = 0\r\n        self.timer = QBasicTimer()\r\n        # plus joli mais fait un peu beuger la pbar !!!\r\n        '''self.setStyleSheet(\"\"\"\r\n                            QProgressBar::chunk\r\n                            {\r\n                                background-color: green\r\n                            }\"\"\")'''\r\n        #self.pbarB.setOrientation(Qt.Orientation.Vertical)\r\n        #self.pbarW.setOrientation(Qt.Orientation.Vertical)\r\n        self.mainLayoutB.addWidget(self.timerButtonB)\r\n        self.mainLayoutW.addWidget(self.timerButtonW)\r\n        self.mainLayoutB.addWidget(self.pbarB)\r\n        self.mainLayoutW.addWidget(self.pbarW)\r\n        self.mainLayoutB.addWidget(self.label_timeRemainingB)\r\n        self.mainLayoutW.addWidget(self.label_timeRemainingW)\r\n        self.skipButtonB = QPushButton('Skip Turn')\r\n        self.skipButtonW = QPushButton('Skip Turn')\r\n        self.skipButtonB.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        self.skipButtonB.clicked.connect(self.buttonSkip_clicked)\r\n        self.mainLayoutB.addWidget(self.skipButtonB)\r\n        self.skipButtonW.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        self.skipButtonW.clicked.connect(self.buttonSkip_clicked)\r\n        self.mainLayoutW.addWidget(self.skipButtonW)\r\n        closeButton = QPushButton('END GAME')\r\n        closeButton.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n        closeButton.clicked.connect(self.buttonEnd_cliked)\r\n        self.rulesButton = QPushButton('How To Play', self)\r\n        self.rulesButton.clicked.connect(self.rules)\r\n        self.mainLayoutM.addWidget(self.rulesButton)\r\n        self.mainLayoutM.addWidget(closeButton)\r\n        self.rulesButton.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))\r\n\r\n        self.borderRed()\r\n\r\n        self.mainWidgetB.setLayout(self.mainLayoutB)\r\n        self.mainWidgetW.setLayout(self.mainLayoutW)\r\n        self.mainWidgetM.setLayout(self.mainLayoutM)\r\n        self.vboxMain.addWidget(self.mainWidgetB)\r\n        self.vboxMain.addWidget(self.mainWidgetW)\r\n        self.vboxMain.addWidget(self.mainWidgetM)\r\n        self.setLayout(self.vboxMain)\r\n\r\n    def center(self):\r\n        '''centers the window on the screen, you do not need to implement this method'''\r\n\r\n    def make_connection(self, board):\r\n        '''this handles a signal sent from the board class'''\r\n        # when the clickLocationSignal is emitted in board the setClickLocation slot receives it\r\n        board.clickLocationSignal.connect(self.setClickLocation)\r\n        # when the updateTimerSignal is emitted in the board the setTimeRemaining slot receives it\r\n        #board.updateTimerSignal.connect(self.setTimeRemaining) #on n'utilise plus le timer de la prof ds board\r\n\r\n    @pyqtSlot(str) # checks to make sure that the following slot is receiving an argument of the type 'int'\r\n    def setClickLocation(self, clickLoc):\r\n        '''updates the label to show the click location'''\r\n        self.label_clickLocation.setText(\"Click Location:\" + clickLoc)\r\n        print('slot ' + clickLoc)\r\n\r\n    '''Méthode de la prof pour afficher le timer de board\r\n    @pyqtSlot(int)\r\n    def setTimeRemaining(self, timeRemainng):\r\n        updates the time remaining label to show the time remaining\r\n        if timeRemainng > 60:\r\n            update = \"Time Remaining:\" + \"1 min \" + str(timeRemainng - 60) + \" s\"\r\n        else:\r\n            update = \"Time Remaining:\" + str(timeRemainng) +\" s\"\r\n\r\n        self.label_timeRemainingB.setText(update)\r\n        print('slot '+update)\r\n        #self.redraw()'''\r\n\r\n    # Here we made the buttonEnd_clicked method to close the window when a player cliks on the End button and\r\n    # to display the End Game Window if it is the end of the game.\r\n\r\n    def buttonEnd_cliked(self):\r\n        if self.go.board.draw:\r\n            self.go.close()\r\n        else:\r\n            print(\"game over\")\r\n            self.go.close()\r\n            self.go.endGameWindow.show()\r\n\r\n    # Here we made the buttonTimerB_clicked method to start/stop the timer when the Player 1 cliks on the Timer button.\r\n    def buttonTimerB_clicked(self):\r\n        self.firstTimer = True\r\n        if self.timer.isActive():\r\n            self.firstTimer = False\r\n            self.timerButtonB.setText('Start')\r\n            self.timerButtonW.setText('Stop')\r\n        elif self.timerButtonB.text() == 'Time Over':\r\n            self.pbarB.setValue(0)\r\n            self.stepB = 0\r\n            self.pbarB.setStyleSheet(\"\"\"\r\n                                QProgressBar::chunk\r\n                                {\r\n                                    background-color: green\r\n                                }\"\"\")\r\n            self.timer.start(1000, self)\r\n            self.timerButtonB.setText('Stop')\r\n        else:\r\n            self.timer.start(1000, self)\r\n            self.timerButtonB.setText('Stop')\r\n\r\n    # Here we made the buttonTimerW_clicked method to start/stop the timer when the Player 2 cliks on the Timer button.\r\n    def buttonTimerW_clicked(self):\r\n        self.firstTimer = False\r\n        if self.timer.isActive():\r\n            self.firstTimer = True\r\n            self.timerButtonW.setText('Start')\r\n            self.timerButtonB.setText('Stop')\r\n        elif self.timerButtonW.text() == 'Time Over':\r\n            self.pbarW.setValue(0)\r\n            self.stepW = 0\r\n            self.pbarW.setStyleSheet(\"\"\"\r\n                                QProgressBar::chunk\r\n                                {\r\n                                    background-color: green\r\n                                }\"\"\")\r\n            self.timer.start(1200, self)\r\n            self.timerButtonW.setText('Stop')\r\n        else:\r\n            self.timer.start(1000, self)\r\n            self.timerButtonW.setText('Stop')\r\n\r\n    # Here we made the timerEvent method to set the timer.\r\n    def timerEvent(self, e):\r\n\r\n        if self.firstTimer:\r\n            self.stepB = self.stepB + 1\r\n            self.pbarB.setValue(self.stepB)\r\n        else:\r\n            self.stepW = self.stepW + 1\r\n            self.pbarW.setValue(self.stepW)\r\n\r\n        if self.stepB < 60:\r\n            update = \"Time Remaining: \" + \"1 min \" + str(60 - self.stepB) + \" s\"\r\n        else:\r\n            update = \"Time Remaining: \" + str(120 - self.stepB) + \" s\"\r\n\r\n        self.label_timeRemainingB.setText(update)\r\n        print('slot ' + update)\r\n\r\n        if self.stepW < 60:\r\n            update = \"Time Remaining: \" + \"1 min \" + str(60 - self.stepW) + \" s\"\r\n        else:\r\n            update = \"Time Remaining: \" + str(120 - self.stepW) + \" s\"\r\n\r\n        self.label_timeRemainingW.setText(update)\r\n        print('slot ' + update)\r\n\r\n        if self.stepB > 100:\r\n            self.pbarB.setStyleSheet(\"\"\"\r\n                    QProgressBar::chunk\r\n                    {\r\n                        background-color: red\r\n                    }\"\"\")\r\n        if self.stepW > 100:\r\n            self.pbarW.setStyleSheet(\"\"\"\r\n                    QProgressBar::chunk\r\n                    {\r\n                        background-color: red\r\n                    }\"\"\")\r\n\r\n        if self.stepB >= 120:\r\n            self.timer.stop()\r\n            self.timerButtonB.setText('Time Over')\r\n            dialog = QMessageBox(self)\r\n            dialog.setWindowTitle(\"Time Over...\")\r\n            dialog.setWindowIcon(QIcon(\"./icons/timer.png\"))\r\n            text = \"Player 1 looses, his time is over.\\n\" \\\r\n                   \"Congratulations to Player 2, you win !\"\r\n\r\n            dialog.setText(text)\r\n            button = dialog.exec()\r\n\r\n            if button == QMessageBox.StandardButton.Ok:\r\n                print(\"OK!\")\r\n        elif self.stepW >= 120:\r\n            self.timer.stop()\r\n            self.timerButtonW.setText('Time Over')\r\n            dialog = QMessageBox(self)\r\n            dialog.setWindowTitle(\"Time Over...\")\r\n            dialog.setWindowIcon(QIcon(\"./icons/timer.png\"))\r\n            text = \"Player 2 looses, his time is  over.\\n\" \\\r\n                   \"Congratulations to Player 1, you win !\"\r\n\r\n            dialog.setText(text)\r\n            button = dialog.exec()\r\n\r\n            if button == QMessageBox.StandardButton.Ok:\r\n                print(\"OK!\")\r\n\r\n    # Here we made the clear method to reset the game.\r\n    def clear(self):\r\n        self.go.board.image = QPixmap(\"./icons/Board.png\")\r\n        self.go.board.resize(800, 1000) #à retravailler !\r\n        self.currentTurn = \"Player 1\"\r\n        self.go.gameLogic.captured[0] = 0\r\n        self.go.gameLogic.captured[1] = 0\r\n        self.stepB = 0\r\n        self.pbarB.setValue(self.stepB)\r\n        self.label_timeRemainingB.setText('Time remaining:')\r\n        self.stepW = 0\r\n        self.pbarW.setValue(self.stepW)\r\n        self.label_timeRemainingW.setText('Time remaining:')\r\n        self.timer = 0\r\n        self.timerButtonB.setText('2 Minute Timer')\r\n        self.timerButtonW.setText('2 Minute Timer')\r\n        '''width = self.width()  # get the width of the current QImage in your application\r\n        height = self.height()  # get the height of the current QImage in your application\r\n        self.go.board.image = image.scaled(height, height)'''\r\n        self.update()\r\n        self.updateUi()\r\n\r\n    # Here we made the buttonSkip_clicked method to skip your turn and change the current player.\r\n    def buttonSkip_clicked(self, s):\r\n        if self.currentTurn == \"Player 1\":\r\n            self.currentTurn = \"Player 2\"\r\n            print(self.currentTurn)\r\n            self.timerButtonB.setText('Start')\r\n            self.timerButtonW.setText('Stop')\r\n            self.firstTimer = False\r\n\r\n        else:\r\n            self.currentTurn = \"Player 1\"\r\n            print(self.currentTurn)\r\n            self.timerButtonW.setText('Start')\r\n            self.timerButtonB.setText('Stop')\r\n            self.firstTimer = True\r\n        self.updateUi()\r\n        if not self.firstSkip:\r\n            self.firstSkip = True\r\n        else:\r\n            print(\"end\")\r\n            # Here we turn the boolean draw into false, and we display a MessageBox to explain that the game\r\n            # is over (two consecutive passes terminates the game).\r\n            self.go.board.draw = False\r\n            dialog = QMessageBox(self)\r\n            dialog.setWindowTitle(\"The End\")\r\n            dialog.setWindowIcon(QIcon(\"./icons/final.jpg\"))\r\n            text = \"The gamer is over.\\n\" \\\r\n                   \"Now, each your turn, click on the pieces you want to delete.\\n\" \\\r\n                    \"When finished, clik on the button END GAME to find out the score and the winner! \uD83D\uDE09 \"\r\n\r\n            dialog.setText(text)\r\n            button = dialog.exec()\r\n\r\n            if button == QMessageBox.StandardButton.Ok:\r\n                print(\"OK!\")\r\n\r\n    # Here we made the matchDetails method to display the game history.\r\n    def matchDetails(self):\r\n        dialog = QMessageBox(self)\r\n        dialog.setWindowTitle(\"Match Details\")\r\n        dialog.setWindowIcon(QIcon(\"./icons/compare-match-icon.png\"))\r\n        text = \"\"\r\n        count = 0\r\n        for i in range(0, 100, 1):\r\n            if self.go.board.tryMove():\r\n                count += 1\r\n                text = str(count) + \".\" + self.currentTurn + \" - \" +\\\r\n                       str(self.go.board.pixelToInt(self.go.board.mouseX, self.go.board.mouseX))\r\n        dialog.setText(text)\r\n        button = dialog.exec()\r\n\r\n        if button == QMessageBox.StandardButton.Ok:\r\n            print(\"OK!\")\r\n        self.updateUi()\r\n\r\n    # Here we made the borderRed method to change the GroupBox's border in red.\r\n    # It changes depending on the current player.\r\n    def borderRed(self):\r\n        #if self.go.board.draw:\r\n        if self.currentTurn == \"Player 1\":\r\n            self.mainWidgetB.setObjectName(\"ColoredGroupBox\")\r\n            self.mainWidgetB.setStyleSheet(\"QGroupBox#ColoredGroupBox { border: 2px solid red;}\")\r\n            self.mainWidgetW.setObjectName(\"ColoredGroupBox\")\r\n            self.mainWidgetW.setStyleSheet(\"QGroupBox#ColoredGroupBox { border: 4px solid white;}\")\r\n        else:\r\n            self.mainWidgetB.setStyleSheet(\"color: white;\"\r\n                                           \"background-color: black\")\r\n            self.mainWidgetW.setObjectName(\"ColoredGroupBox\")\r\n            self.mainWidgetW.setStyleSheet(\"QGroupBox#ColoredGroupBox { border: 2px solid red;}\")\r\n            self.mainWidgetB.setObjectName(\"ColoredGroupBox\")\r\n            self.mainWidgetB.setStyleSheet(\"QGroupBox#ColoredGroupBox { border: 2px solid black;}\")\r\n\r\n    # Here we made the rules method to display a message box with the rules of the game.\r\n    def rules(self):\r\n        dialog = QMessageBox(self)\r\n        dialog.setWindowTitle(\"Rules\")\r\n        dialog.setWindowIcon(QIcon(\"./icons/rules.png\"))\r\n        text = \"A game of Go starts with an empty board.\\n\" \\\r\n                \"Each player has an effectively unlimited supply\\n\" \\\r\n                \"of pieces (called stones), one taking the black stones,\\n\" \\\r\n                \"the other taking white ones. The main object of the game\\n\" \\\r\n                \"is to use your stones to form territories by surrounding\\n\" \\\r\n                \"vacant areas of the board. It is also possible to capture\\n\" \\\r\n                \"your opponent's stones by completely surrounding them.\\n\" \\\r\n                \"Players take turns, placing one of their stones\\n\" \\\r\n                \"on a vacant point at each turn, with Black playing first.\\n\" \\\r\n                \"Note that stones are placed on the intersections of the lines\\n\" \\\r\n                \"rather than in the squares and once played stones are not moved.\\n\" \\\r\n                \"However they may be captured, in which case they are removed,\\n\" \\\r\n                \"and kept by the capturing player as prisoners.\\n\" \\\r\n                \"Let the games begin ! \uD83D\uDE0A\"\r\n\r\n        dialog.setText(text)\r\n        button = dialog.exec()\r\n\r\n        if button == QMessageBox.StandardButton.Ok:\r\n            print(\"OK!\")\r\n\r\n    # Here we made the updateUI method to update the UI.\r\n    def updateUi(self):\r\n        self.playerLabel.setText(\"Current Turn: \" + self.currentTurn)\r\n        self.playerLabel.adjustSize()\r\n        self.captureW.setText(\"Captures : \" + str(self.go.gameLogic.captured[1]))\r\n        self.captureW.adjustSize()\r\n        self.captureB.setText(\"Captures : \" + str(self.go.gameLogic.captured[0]))\r\n        self.captureB.adjustSize()\r\n        self.borderRed()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py
--- a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
+++ b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py	(date 1670844441873)
@@ -16,7 +16,6 @@
 
         self.vboxMain = QVBoxLayout()
         self.firstTimer = False
-        self.firstSkip = False
 
         # Here we create 3 GroupBoxs to hold other widgets : one for Player 1, one for Player 2 and one for other things
         # needed to play the game.
@@ -72,12 +71,6 @@
         self.stepB = 0
         self.stepW = 0
         self.timer = QBasicTimer()
-        # plus joli mais fait un peu beuger la pbar !!!
-        '''self.setStyleSheet("""
-                            QProgressBar::chunk
-                            {
-                                background-color: green
-                            }""")'''
         #self.pbarB.setOrientation(Qt.Orientation.Vertical)
         #self.pbarW.setOrientation(Qt.Orientation.Vertical)
         self.mainLayoutB.addWidget(self.timerButtonB)
@@ -222,12 +215,18 @@
         print('slot ' + update)
 
         if self.stepB > 100:
+            self.pbarB.setFormat('Hurry up!')
+            self.pbarB.setAlignment(Qt.AlignmentFlag.AlignCenter)
+            self.pbarB.setTextVisible(True)
             self.pbarB.setStyleSheet("""
                     QProgressBar::chunk
                     {
                         background-color: red
                     }""")
         if self.stepW > 100:
+            self.pbarW.setFormat('Hurry up!')
+            self.pbarW.setAlignment(Qt.AlignmentFlag.AlignCenter)
+            self.pbarW.setTextVisible(True)
             self.pbarW.setStyleSheet("""
                     QProgressBar::chunk
                     {
@@ -289,21 +288,23 @@
     def buttonSkip_clicked(self, s):
         if self.currentTurn == "Player 1":
             self.currentTurn = "Player 2"
+            self.go.gameLogic.currentPlayer = 2
             print(self.currentTurn)
             self.timerButtonB.setText('Start')
             self.timerButtonW.setText('Stop')
             self.firstTimer = False
+            self.go.board.count += 1
 
         else:
             self.currentTurn = "Player 1"
+            self.go.gameLogic.currentPlayer = 1
             print(self.currentTurn)
             self.timerButtonW.setText('Start')
             self.timerButtonB.setText('Stop')
             self.firstTimer = True
+            self.go.board.count += 1
         self.updateUi()
-        if not self.firstSkip:
-            self.firstSkip = True
-        else:
+        if self.go.board.count == 2:
             print("end")
             # Here we turn the boolean draw into false, and we display a MessageBox to explain that the game
             # is over (two consecutive passes terminates the game).
@@ -313,7 +314,7 @@
             dialog.setWindowIcon(QIcon("./icons/final.jpg"))
             text = "The gamer is over.\n" \
                    "Now, each your turn, click on the pieces you want to delete.\n" \
-                    "When finished, clik on the button END GAME to find out the score and the winner! 😉 "
+                   "When finished, clik on the button END GAME to find out the score and the winner! 😉 "
 
             dialog.setText(text)
             button = dialog.exec()
Index: .idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45__Changes_1.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45__Changes_1.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45__Changes_1.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45__Changes_1.xml	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
+++ /dev/null	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_04_12_2022_18_45_[Changes]1" date="1670179545790" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45_[Changes]1/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 04/12/2022 18:45 [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45_[Changes]1/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45_[Changes]1/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45_[Changes]1/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45_[Changes]1/shelved.patch	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
+++ /dev/null	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
@@ -1,19 +0,0 @@
-Index: studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py
---- a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py	
-+++ b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py	
-@@ -13,8 +13,8 @@
-     def initUI(self):
-         '''initiates ScoreBoard UI'''
-         ''''IMPORTANT '''
--        # pour t'expliquer, j'aimerai créer 3 QGroupBox : une pour le player 1, une pour le player 2 et une autre pour les
--        # match details sauf que pour avoir 3 QGroupBox à la suite il faut créer une GridLayout et y ajouter les QGroupBox
-+        # pour t'expliquer, j'aimerai créer 4 QGroupBox : une pour le player 1, une pour le player 2 et une autre pour les
-+        # match details sauf que pour avoir 4 QGroupBox à la suite il faut créer une GridLayout et y ajouter les QGroupBox
-         # sauf que pour l'instant la grid se créée dans une nouvelle fenêtre au lieu de se mettre à droite du plateau
-         # peux-tu regarder dans la classe go stp ? Merci :)
-         # B pour black, W pour white, M pour match et R pour rules
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"479b13f7-e2c4-4d1d-bb7d-065a8c4fcde2\" name=\"Changes\" comment=\"yesss\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/Projet-HCI.iml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/Projet-HCI.iml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/misc.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/misc.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProblemsViewState\">\r\n    <option name=\"selectedTabId\" value=\"ProjectErrors\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2HuThy9akMsCEQ8ns6XgMNgN8AU\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;codeWithMe.voiceChat.enabledByDefault&quot;: &quot;false&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/yann0/PycharmProjects/Projet-HCI/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/__main__.py&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\yann0\\PycharmProjects\\Projet-HCI\\studentAnswerTemplate-20221122\\HGP_GroupNumber_Project\\code\\icons\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"__main__\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\r\n      <module name=\"Projet-HCI\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/__main__.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"479b13f7-e2c4-4d1d-bb7d-065a8c4fcde2\" name=\"Changes\" comment=\"\" />\r\n      <created>1669134092166</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1669134092166</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"test\">\r\n      <created>1669134736056</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669134736056</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"test\">\r\n      <created>1669135752757</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669135752757</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"test\">\r\n      <created>1669135845151</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669135845151</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"test\">\r\n      <created>1669158634783</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669158634783</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"test\">\r\n      <created>1669401725514</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669401725514</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"test\">\r\n      <created>1669557510839</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669557510839</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"test\">\r\n      <created>1669656002510</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669656002510</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"test\">\r\n      <created>1669717761448</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669717761448</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"test\">\r\n      <created>1669723950284</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669723950284</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"test\">\r\n      <created>1669744197084</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669744197084</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"test\">\r\n      <created>1669811231638</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669811231638</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"test\">\r\n      <created>1669819851440</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669819851440</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"test\">\r\n      <created>1669820404702</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669820404702</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00014\" summary=\"test\">\r\n      <created>1669820636366</created>\r\n      <option name=\"number\" value=\"00014\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669820636366</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00015\" summary=\"test\">\r\n      <created>1669820655499</created>\r\n      <option name=\"number\" value=\"00015\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669820655499</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00016\" summary=\"cc\">\r\n      <created>1669821988939</created>\r\n      <option name=\"number\" value=\"00016\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669821988939</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00017\" summary=\"cc\">\r\n      <created>1669827577731</created>\r\n      <option name=\"number\" value=\"00017\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669827577731</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00018\" summary=\"cc\">\r\n      <created>1669851210164</created>\r\n      <option name=\"number\" value=\"00018\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669851210164</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00019\" summary=\"cc\">\r\n      <created>1669903230274</created>\r\n      <option name=\"number\" value=\"00019\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669903230274</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00020\" summary=\"cc\">\r\n      <created>1669986070156</created>\r\n      <option name=\"number\" value=\"00020\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669986070156</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00021\" summary=\"tkt ça passe à peu près 2\">\r\n      <created>1670202613499</created>\r\n      <option name=\"number\" value=\"00021\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670202613499</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00022\" summary=\"score1\">\r\n      <created>1670205714342</created>\r\n      <option name=\"number\" value=\"00022\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670205714342</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00023\" summary=\"cc\">\r\n      <created>1670249755212</created>\r\n      <option name=\"number\" value=\"00023\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670249755212</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00024\" summary=\"cc\">\r\n      <created>1670249770787</created>\r\n      <option name=\"number\" value=\"00024\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670249770787</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00025\" summary=\"cc\">\r\n      <created>1670320624353</created>\r\n      <option name=\"number\" value=\"00025\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670320624353</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00026\" summary=\"cc\">\r\n      <created>1670420208214</created>\r\n      <option name=\"number\" value=\"00026\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670420208214</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00027\" summary=\"emmaa\">\r\n      <created>1670420333348</created>\r\n      <option name=\"number\" value=\"00027\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00027\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670420333348</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00028\" summary=\"emmaa\">\r\n      <created>1670525257988</created>\r\n      <option name=\"number\" value=\"00028\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00028\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670525257988</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00029\" summary=\"emmaa\">\r\n      <created>1670586722757</created>\r\n      <option name=\"number\" value=\"00029\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00029\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670586722757</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00030\" summary=\"emmma\">\r\n      <created>1670587035262</created>\r\n      <option name=\"number\" value=\"00030\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00030\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670587035262</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00031\" summary=\"emmma\">\r\n      <created>1670587069389</created>\r\n      <option name=\"number\" value=\"00031\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00031\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670587069389</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00032\" summary=\"emmmmmmaaa\">\r\n      <created>1670591533115</created>\r\n      <option name=\"number\" value=\"00032\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00032\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670591533115</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00033\" summary=\"ça MARCHE !!!!!!!!\">\r\n      <created>1670639836494</created>\r\n      <option name=\"number\" value=\"00033\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00033\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1670639836494</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"34\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"test\" />\r\n    <MESSAGE value=\"tkt ça passe à peu près 2\" />\r\n    <MESSAGE value=\"score1\" />\r\n    <MESSAGE value=\"cc\" />\r\n    <MESSAGE value=\"emmaa\" />\r\n    <MESSAGE value=\"emmma\" />\r\n    <MESSAGE value=\"emmmmmmaaa\" />\r\n    <MESSAGE value=\"ça MARCHE !!!!!!!!\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"ça MARCHE !!!!!!!!\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision ec40daa2d6dc14b5fd7cf8f8c0d1e76979649164)
+++ b/.idea/workspace.xml	(date 1670849642429)
@@ -1,11 +1,15 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="479b13f7-e2c4-4d1d-bb7d-065a8c4fcde2" name="Changes" comment="yesss">
-      <change beforePath="$PROJECT_DIR$/.idea/Projet-HCI.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/Projet-HCI.iml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
+    <list default="true" id="479b13f7-e2c4-4d1d-bb7d-065a8c4fcde2" name="Changes" comment="scoreboardd">
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45_[Changes]1/shelved.patch" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_04_12_2022_18_45__Changes_1.xml" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/BSC-HGP - Project - UI Design DocumentV1.docx" beforeDir="false" afterPath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/BSC-HGP - Project - UI Design DocumentV1.docx" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py" beforeDir="false" afterPath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py" beforeDir="false" afterPath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/game_logic.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/go.py" beforeDir="false" afterPath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/go.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/icons/logo.png" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py" beforeDir="false" afterPath="$PROJECT_DIR$/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/score_board.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -311,7 +315,14 @@
       <option name="project" value="LOCAL" />
       <updated>1670639836494</updated>
     </task>
-    <option name="localTasksCounter" value="34" />
+    <task id="LOCAL-00034" summary="scoreboardd">
+      <created>1670700418552</created>
+      <option name="number" value="00034" />
+      <option name="presentableId" value="LOCAL-00034" />
+      <option name="project" value="LOCAL" />
+      <updated>1670700418552</updated>
+    </task>
+    <option name="localTasksCounter" value="35" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -334,6 +345,7 @@
     <MESSAGE value="emmma" />
     <MESSAGE value="emmmmmmaaa" />
     <MESSAGE value="ça MARCHE !!!!!!!!" />
-    <option name="LAST_COMMIT_MESSAGE" value="ça MARCHE !!!!!!!!" />
+    <MESSAGE value="scoreboardd" />
+    <option name="LAST_COMMIT_MESSAGE" value="scoreboardd" />
   </component>
 </project>
\ No newline at end of file
