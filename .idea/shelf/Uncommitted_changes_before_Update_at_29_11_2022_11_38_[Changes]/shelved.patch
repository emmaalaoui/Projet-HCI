Index: studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from PyQt6.QtWidgets import QFrame, QProgressBar\r\nfrom PyQt6.QtCore import Qt, QBasicTimer, pyqtSignal, QPointF, QPoint\r\nfrom PyQt6.QtGui import QPainter, QPixmap, QPen, QBrush\r\nfrom PyQt6.QtTest import QTest\r\nfrom piece import Piece\r\n#from score_board import ScoreBoard\r\n\r\nclass Board(QFrame):  # base the board on a QFrame widget\r\n    updateTimerSignal = pyqtSignal(int) # signal sent when timer is updated\r\n    clickLocationSignal = pyqtSignal(str) # signal sent when there is a new click location\r\n\r\n    # TODO set the board width and height to be square\r\n    boardWidth  = 50     # board is 0 squares wide # TODO this needs updating\r\n    boardHeight = 50     #\r\n    timerSpeed  = 1000     # the timer updates every 1 millisecond\r\n    counter     = 60    # the number the counter will count down from\r\n\r\n\r\n    def __init__(self, parent):\r\n        super().__init__(parent)\r\n        self.initBoard()\r\n        self.image = QPixmap(\"./icons/Board.png\")\r\n\r\n\r\n    def resizeEvent(self, event):\r\n        self.image = self.image.scaled(self.width(), self.height())\r\n\r\n    def initBoard(self):\r\n        '''initiates board'''\r\n        self.timer = QBasicTimer()  # create a timer for the game\r\n        self.isStarted = False      # game is not currently started\r\n        #self.start()                # start the game which will start the timer\r\n        #0 représente une case vide, 1 représente les noirs (ce joueur commence) et 2 représente les blancs\r\n        self.a = 0\r\n        self.b = 0\r\n        self.c = 0\r\n        self.d = 0\r\n        self.e = 0\r\n        self.f = 0\r\n        self.g = 0\r\n        self.h = 0\r\n        self.i = 0\r\n        self.j = 0\r\n        self.k = 0\r\n        self.l = 0\r\n        self.m = 0\r\n        self.n = 0\r\n        self.o = 0\r\n        self.p = 0\r\n        self.q = 0\r\n        self.r = 0\r\n        self.s = 0\r\n        self.t = 0\r\n        self.u = 0\r\n        self.v = 0\r\n        self.w = 0\r\n        self.x = 0\r\n        self.y = 0\r\n        self.z = 0\r\n        self.ab = 0\r\n        self.ac = 0\r\n        self.ad = 0\r\n        self.ae = 0\r\n        self.af = 0\r\n        self.ag = 0\r\n        self.ah = 0\r\n        self.ai = 0\r\n        self.aj = 0\r\n        self.ak = 0\r\n        self.al = 0\r\n        self.am = 0\r\n        self.an = 0\r\n        self.ao = 0\r\n        self.ap = 0\r\n        self.aq = 0\r\n        self.ar = 0\r\n        self.ay = 0\r\n        self.at = 0\r\n        self.au = 0\r\n        self.av = 0\r\n        self.aw = 0\r\n        self.ax = 0\r\n        #il y'a 49 intersections donc on doit créer un tableau avc 49 cases et le remplir de 0, 1 ou 2\r\n        '''[self.a, self.b, self.c, self.d, self.e, self.f, self.g],\r\n          [self.h, self.i, self.j, self.k, self.l, self.m, self.n],\r\n          [self.o, self.p, self.q, self.r, self.s, self.t, self.u],\r\n          [self.v, self.w, self.x, self.y, self.z, self.ab, self.ac],\r\n          [self.ad, self.ae, self.af, self.ag, self.ah, self.ai, self.aj],\r\n          [self.ak, self.al, self.am, self.an, self.ao, self.ap, self.aq],\r\n          [self.ar, self.ay, self.at, self.au, self.av, self.aw, self.ax],'''\r\n\r\n        self.boardArray = []        # TODO - create a 2d int/Piece array to store the state of the game\r\n        self.printBoardArray()    # TODO - uncomment this method after creating the array above\r\n\r\n    def printBoardArray(self):\r\n        '''prints the boardArray in an attractive way'''\r\n        print(\"boardArray:\")\r\n        print('\\n'.join(['\\t'.join([str(cell) for cell in row]) for row in self.boardArray]))\r\n\r\n    def mousePosToColRow(self, event):\r\n        '''convert the mouse click event to a row and column'''\r\n\r\n    def squareWidth(self):\r\n        '''returns the width of one square in the board'''\r\n        return self.contentsRect().width() / self.boardWidth\r\n\r\n    def squareHeight(self):\r\n        '''returns the height of one square of the board'''\r\n        return self.contentsRect().height() / self.boardHeight\r\n\r\n    def start(self):\r\n        '''starts game'''\r\n        self.isStarted = True                       # set the boolean which determines if the game has started to TRUE\r\n        self.resetGame()                            # reset the game\r\n        self.timer.start(self.timerSpeed, self)     # start the timer with the correct speed\r\n        print(\"start () - timer is started\")\r\n\r\n\r\n    def timerEvent(self, event):\r\n        '''this event is automatically called when the timer is updated. based on the timerSpeed variable '''\r\n        # TODO adapt this code to handle your timers\r\n        if event.timerId() == self.timer.timerId():  # if the timer that has 'ticked' is the one in this class\r\n            if self.counter == 1:\r\n                print(\"Game over\")\r\n                self.timer.stop()\r\n            self.counter -= 1\r\n            '''ScoreBoard.pbar.setValue(0)\r\n            ScoreBoard.step = ScoreBoard.step + 1\r\n            ScoreBoard.pbar.setValue(ScoreBoard.step)'''\r\n            print('timerEvent()', self.counter)\r\n            self.updateTimerSignal.emit(self.counter)\r\n        else:\r\n            super(Board, self).timerEvent(event)      # if we do not handle an event we should pass it to the super\r\n                                                        # class for handling\r\n\r\n    def paintEvent(self, event):\r\n        '''paints the board and the pieces of the game'''\r\n        painter = QPainter(self)\r\n        painter.drawPixmap(QPoint(), self.image)\r\n        #self.drawBoardSquares(painter) #we don't draw the board bc we use a background\r\n        self.drawPieces(painter)\r\n\r\n    def mousePressEvent(self, event):\r\n        '''this event is automatically called when the mouse is pressed'''\r\n        clickLoc = \"click location [\"+str(event.position().x())+\",\"+str(event.position().y())+\"]\"     # the location where a mouse click was registered\r\n        print(\"mousePressEvent() - \"+clickLoc)\r\n        self.X = event.position().x()\r\n        self.Y = event.position().y()\r\n        print(self.X, self.Y)\r\n        # TODO you could call some game logic here\r\n        self.clickLocationSignal.emit(clickLoc)\r\n\r\n    def resetGame(self):\r\n        '''clears pieces from the board'''\r\n        # TODO write code to reset game\r\n        '''\r\n        self.image = QPixmap(\"./icons/Board.png\")\r\n        width = self.width()  # get the width of the current QImage in your application\r\n        height = self.height()  # get the height of the current QImage in your application\r\n        self.image = self.image.scaled(width, height)\r\n        '''\r\n\r\n    def tryMove(self, newX, newY):\r\n        '''tries to move a piece'''\r\n        '''\r\n        Equation d'un cercle : (x−h)²+(y−k)²=r².\r\n        Si newX et newY vérifie l'équation alors le point est dans la zone\r\n        h : commence à 146 puis on ajoute 90 à chaque fois qu'on se décale sur la droite\r\n        y : commence à 176 puis on ajoute 110 à chaque fois qu'on se décale vers le bas\r\n        '''\r\n\r\n    def drawBoardSquares(self, painter):\r\n        '''draw all the square on the board'''\r\n        # TODO set the default colour of the brush\r\n        # draw settings (default)\r\n        self.drawing = False\r\n        self.brushSize = 3\r\n        self.brushColor = Qt.GlobalColor.black  # documentation: https://doc.qt.io/qt-6/qt.html#GlobalColor-enum\r\n        for row in range(0, Board.boardHeight):\r\n            for col in range (0, Board.boardWidth):\r\n                painter.save()\r\n                colTransformation = self.squareWidth()* col # TODO set this value equal the transformation in the column direction\r\n                rowTransformation = 0                       # TODO set this value equal the transformation in the row direction\r\n                painter.translate(colTransformation,rowTransformation)\r\n                painter.fillRect()                          # TODO provide the required arguments\r\n                painter.restore()\r\n                # TODO change the colour of the brush so that a checkered board is drawn\r\n\r\n    def drawPieces(self, painter):\r\n        '''draw the pieces on the board'''\r\n        self.brushSize = 5\r\n        #painter = QPainter(self.image)\r\n        #if player 1 : Comment aller chercher l'attribut self.currentTurn de ScoreBoard ?\r\n        painter.setPen(QPen(Qt.GlobalColor.black, self.brushSize))\r\n        painter.setBrush(QBrush(Qt.GlobalColor.black, Qt.BrushStyle.SolidPattern))\r\n\r\n        '''\r\n        if player 2 :\r\n        painter.setPen(QPen(Qt.GlobalColor.white, self.brushSize))\r\n        painter.setBrush(QBrush(Qt.GlobalColor.white, Qt.BrushStyle.SolidPattern))\r\n        \r\n        '''\r\n        radius = self.squareWidth() / 4\r\n        center = QPointF(radius, radius)\r\n        #painter.drawEllipse(center, radius, radius)\r\n        painter.drawEllipse(125, 155, 50, 50)\r\n        #A utiliser qu'à partir du moment où l'utilisateur clique sur la souris\r\n        #painter.drawEllipse(self.X, self.Y, 400, 200)\r\n        '''colour = Qt.GlobalColor.transparent # empty square could be modeled with transparent pieces\r\n        for row in range(0, len(self.boardArray)):\r\n            for col in range(0, len(self.boardArray[0])):\r\n                painter.save()\r\n                painter.translate()\r\n\r\n                # TODO draw some the pieces as ellipses\r\n                # TODO choose your colour and set the painter brush to the correct colour\r\n                # draw settings (default)\r\n                self.drawing = False\r\n                self.brushSize = 3\r\n                colour = Qt.GlobalColor.black\r\n                radius = self.squareWidth() / 4\r\n                center = QPointF(radius, radius)\r\n                painter.drawEllipse(center, radius, radius)\r\n                painter.restore()'''\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py
--- a/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py	(revision c0dfc3a66bf000a5c1af631844310f57f4cb124b)
+++ b/studentAnswerTemplate-20221122/HGP_GroupNumber_Project/code/board.py	(date 1669721900795)
@@ -203,9 +203,9 @@
         radius = self.squareWidth() / 4
         center = QPointF(radius, radius)
         #painter.drawEllipse(center, radius, radius)
-        painter.drawEllipse(125, 155, 50, 50)
+        #painter.drawEllipse(125, 155, 50, 50)
         #A utiliser qu'à partir du moment où l'utilisateur clique sur la souris
-        #painter.drawEllipse(self.X, self.Y, 400, 200)
+        painter.drawEllipse(self.X, self.Y, 400, 200)
         '''colour = Qt.GlobalColor.transparent # empty square could be modeled with transparent pieces
         for row in range(0, len(self.boardArray)):
             for col in range(0, len(self.boardArray[0])):
